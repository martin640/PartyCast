package partycast.server;

import android.text.TextUtils;
import android.util.Log;

import org.java_websocket.WebSocket;
import org.java_websocket.drafts.Draft;
import org.java_websocket.exceptions.InvalidDataException;
import org.java_websocket.framing.CloseFrame;
import org.java_websocket.handshake.ClientHandshake;
import org.java_websocket.handshake.ServerHandshakeBuilder;
import org.java_websocket.server.WebSocketServer;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import partycast.model.LibraryItem;
import partycast.model.LibraryProvider;
import partycast.model.Lobby;
import partycast.model.LobbyEventListener;
import partycast.model.LobbyMember;
import partycast.model.OperationRejectedException;
import partycast.model.QueueLooper;
import partycast.model.VolumeControl;
import sk.martin64.partycast.utils.Callback;

public class ServerLobby implements Lobby, JSONable {

    /**
     * Determines whether server should cache user data by IP address.
     * This should be false in public server.
     */
    public static final boolean FLAG_USER_CACHE = true;

    private WebSocketServer socketServer;
    private InetSocketAddress socketAddress;
    private Map<WebSocket, ServerLobbyMember> membersByWS;
    private Map<String, ServerLobbyMember> memberCacheByIP;

    private String title;
    private List<ServerLobbyMember> members;
    private ServerLobbyMember selfMember;
    private LibraryProvider libraryProvider;
    private QueueLooper looper;

    final List<LobbyEventListener> listenersUnsafe;

    private int memberIdPool;

    protected int state;
    protected int playbackState;

    protected ServerLobby(String title, int port, String username, LobbyEventListener listener) {
        this.title = title;
        socketAddress = new InetSocketAddress(port);

        this.members = new ArrayList<>();
        this.membersByWS = new HashMap<>();
        this.memberCacheByIP = new HashMap<>();
        this.listenersUnsafe = new ArrayList<>();
        this.listenersUnsafe.add(listener);

        this.selfMember = new ServerLobbyMember(username, ++memberIdPool, LobbyMember.PERMISSION_HOST, "Server", null, this) {
            @Override
            void changePermissionsInternally(int permissions) {
                // disallow changing permissions for admin
            }

            @Override
            public void kick(Callback<Void> callback) {
                callback.onError(new OperationRejectedException("Cannot kick server owner"));
            }

            @Override
            public void ban(Callback<Void> callback) {
                callback.onError(new OperationRejectedException("Cannot ban server owner"));
            }
        };
        this.members.add(this.selfMember);
    }

    /**
     * Called from extending class after its variables has been initialized and server is ready to be started
     * @param libraryProvider platform specific LibraryProvider generated by extended class
     * @param queueLooper platform specific QueueLooper generated by extended class
     */
    protected void prepare(LibraryProvider libraryProvider, QueueLooper queueLooper) {
        this.libraryProvider = libraryProvider;
        this.looper = queueLooper;

        this.state = STATE_CONNECTING;
        socketServer = new WebSocketServer(socketAddress) {

            @Override
            public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer(WebSocket conn, Draft draft, ClientHandshake request) throws InvalidDataException {
                ServerHandshakeBuilder builder = super.onWebsocketHandshakeReceivedAsServer(conn, draft, request);
                builder.put("PartyCast-Lobby-Name", title);
                return builder;
            }

            @Override
            public void onOpen(WebSocket conn, ClientHandshake handshake) {
                ServerLobbyMember newMember;

                if (FLAG_USER_CACHE) {
                    newMember = memberCacheByIP.get(conn.getRemoteSocketAddress().getAddress().getHostAddress());
                    if (newMember != null) {
                        if (members.contains(newMember)) {
                            conn.send("Connect failed: IP already connected");
                            conn.close(CloseFrame.REFUSE, "IP already connected");
                            return;
                        }

                        newMember.connection = conn;
                    }
                }

                if (newMember == null) {
                    String newName = handshake.getFieldValue("PartyCast-Username");

                    if (TextUtils.isEmpty(newName))
                        newName = conn.getRemoteSocketAddress().getAddress().getHostName();

                    if (TextUtils.isEmpty(newName))
                        newName = conn.getRemoteSocketAddress().getAddress().getHostAddress();

                    if (TextUtils.isEmpty(newName)) {
                        conn.send("Connect failed: Invalid name provided");
                        conn.close(CloseFrame.REFUSE, "Invalid name provided");
                        return;
                    }

                    for (ServerLobbyMember member : members) {
                        if (Objects.equals(member.getName(), newName)) {
                            conn.send("Connect failed: Username is already in use");
                            conn.close(CloseFrame.REFUSE, "Username is already in use");
                            return;
                        }
                    }

                    newMember = new ServerLobbyMember(newName, ++memberIdPool, LobbyMember.PERMISSIONS_DEFAULT,
                            handshake.getFieldValue("User-Agent"), conn, ServerLobby.this);
                }

                // acknowledge existing users before pushing new member to list
                broadcastEvent("Event.USER_JOINED", newMember);
                members.add(newMember);
                membersByWS.put(conn, newMember);

                if (FLAG_USER_CACHE)
                    memberCacheByIP.put(conn.getRemoteSocketAddress().getAddress().getHostAddress(), newMember);

                // push all data to new client
                sendEvent(newMember, "LobbyCtl.DATA_PUSH", ServerLobby.this);

                for (LobbyEventListener l : safeListenersCopy())
                    l.onUserJoined(ServerLobby.this, newMember);
            }

            @Override
            public void onClose(WebSocket conn, int code, String reason, boolean remote) {
                ServerLobbyMember member = membersByWS.get(conn);
                if (member != null) {
                    membersByWS.remove(conn);
                    members.remove(member);
                    broadcastEvent("Event.USER_LEFT", member);

                    for (LobbyEventListener l : safeListenersCopy())
                        l.onUserLeft(ServerLobby.this, member);
                }
            }

            @Override
            public void onMessage(WebSocket conn, String message) {
                ServerLobbyMember member = membersByWS.get(conn);
                if (member != null) {
                    try {
                        JSONObject messageData = new JSONObject(message);
                        String eventType = messageData.getString("type");
                        int mid = messageData.optInt("id", -1);

                        if (eventType.equals("LobbyCtl.UPDATE_USER")) {
                            JSONObject data = messageData.getJSONObject("value");
                            if (data.optInt("id", member.getId()) == member.getId() &&
                                    Lobby.checkPermission(member, LobbyMember.PERMISSION_CHANGE_NAME)) {

                                handleUsernameChange(conn, member, mid, data);
                            } else if (Lobby.checkPermission(member, LobbyMember.PERMISSION_MANAGE_USERS)) {
                                handleUserUpdate(conn, getMemberById(data.optInt("id", member.getId())), mid, data);
                            } else {
                                conn.send(new JSONObject()
                                        .put("id", mid)
                                        .put("type", "LobbyCtl.RESPONSE")
                                        .put("status", -5)
                                        .put("message", "Action rejected")
                                        .toString());
                            }
                        } else if (eventType.equals("LobbyCtl.ENQUEUE") && Lobby.checkPermission(member, LobbyMember.PERMISSION_QUEUE)) {
                            JSONObject data = messageData.getJSONObject("value");
                            int id = data.optInt("id");
                            LibraryItem item = libraryProvider.findItemById(id);
                            if (item != null) {
                                looper.enqueue(item, member, responseOnCallback(conn, mid));
                            } else {
                                conn.send(new JSONObject()
                                        .put("id", mid)
                                        .put("type", "LobbyCtl.RESPONSE")
                                        .put("status", -5)
                                        .put("message", "Action rejected")
                                        .toString());
                            }
                        } else if (eventType.equals("LobbyCtl.PLAYBACK_PLAY") && Lobby.checkPermission(member, LobbyMember.PERMISSION_MANAGE_QUEUE)) {
                            looper.play(responseOnCallback(conn, mid));
                        } else if (eventType.equals("LobbyCtl.PLAYBACK_PAUSE") && Lobby.checkPermission(member, LobbyMember.PERMISSION_MANAGE_QUEUE)) {
                            looper.pause(responseOnCallback(conn, mid));
                        } else if (eventType.equals("LobbyCtl.PLAYBACK_SKIP") && Lobby.checkPermission(member, LobbyMember.PERMISSION_MANAGE_QUEUE)) {
                            looper.skip(responseOnCallback(conn, mid));
                        } else {
                            System.err.println("Unhandled message: " + eventType);
                        }
                    } catch (JSONException e) {
                        e.printStackTrace();
                        conn.send("Failed to handle message: Json parse error");
                    }
                } else {
                    conn.send("Unable to identify remote user: Unauthorized");
                }
            }

            @Override
            public void onError(WebSocket conn, Exception ex) {
                ex.printStackTrace();

                if (conn == null) { // exception on server level
                    internalShutdown(ex);
                }
            }

            @Override
            public void onStart() {
                state = STATE_OPEN;
                System.out.println("ServerLobby started");

                for (LobbyEventListener l : safeListenersCopy())
                    l.onConnected(ServerLobby.this);
                new Object();
            }
        };
        socketServer.start();
    }

    /**
     * Internally shutdowns server.
     * Default implementation closes websocket server,
     * changes server state to STATE_CLOSED and broadcasts error event to all local event listeners.
     * Extending this function should call super function at the end of function as original function changes server state.
     * @param reason reason when server is closing
     */
    public void internalShutdown(Exception reason) {
        try {
            socketServer.stop();
            state = STATE_CLOSED;

            for (LobbyEventListener l : safeListenersCopy())
                l.onError(ServerLobby.this, reason);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Sends message to specific member
     * @param member target memeber
     * @param type event type
     * @param data event data
     */
    public void sendEvent(ServerLobbyMember member, String type, JSONable data) {
        WebSocket ws = member.getConnection();
        if (ws != null && ws.isOpen()) {
            try {
                JSONObject dataJson = new JSONObject();
                data.toJSON(dataJson);
                ws.send(new JSONObject()
                        .put("type", type)
                        .put("data", dataJson)
                        .put("clientId", member.getId())
                        .toString());
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Sends broadcast to all connected clients
     * @param type event type
     * @param data event data
     */
    public void broadcastEvent(String type, JSONable data) {
        for (ServerLobbyMember member : members) {
            WebSocket conn = member.getConnection();
            if (conn != null && conn.isOpen()) {
                try {
                    JSONObject dataJson = new JSONObject();
                    data.toJSON(dataJson);
                    conn.send(new JSONObject()
                            .put("type", type)
                            .put("data", dataJson)
                            .put("clientId", member.getId())
                            .toString());
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Helper function to respond to message as soon as Callback is called.
     */
    <T> Callback<T> responseOnCallback(WebSocket conn, int mid) {
        return new Callback<T>() {
            @Override
            public void onError(Exception e) {
                try {
                    conn.send(new JSONObject()
                            .put("id", mid)
                            .put("type", "LobbyCtl.RESPONSE")
                            .put("status", -1)
                            .put("message", e.getMessage())
                            .toString());
                } catch (JSONException ee) {
                }
            }

            @Override
            public void onSuccess(T looper) {
                try {
                    conn.send(new JSONObject()
                            .put("id", mid)
                            .put("type", "LobbyCtl.RESPONSE")
                            .put("status", 0)
                            .put("message", "OK")
                            .toString());
                } catch (JSONException e) {
                }
            }
        };
    }

    private void handleUsernameChange(WebSocket conn, ServerLobbyMember user, int messageId, JSONObject data) throws JSONException {
        String newName = data.optString("name");
        if (TextUtils.isEmpty(newName))
            newName = conn.getRemoteSocketAddress().getAddress().getHostAddress();
        if (TextUtils.isEmpty(newName)) {
            conn.send(new JSONObject()
                    .put("id", messageId)
                    .put("type", "LobbyCtl.RESPONSE")
                    .put("status", -1)
                    .put("message", "Invalid name provided")
                    .toString());
            return;
        }
        for (ServerLobbyMember mem : members) {
            if (Objects.equals(mem.getName(), newName)) {
                conn.send(new JSONObject()
                        .put("id", messageId)
                        .put("type", "LobbyCtl.RESPONSE")
                        .put("status", -1)
                        .put("message", "Username is already in use")
                        .toString());
                return;
            }
        }

        user.changeNameInternally(newName);
        conn.send(new JSONObject()
                .put("id", messageId)
                .put("type", "LobbyCtl.RESPONSE")
                .put("status", 0)
                .put("message", "Username updated")
                .toString());

        broadcastEvent("Event.USER_UPDATED", user);

        for (LobbyEventListener l : safeListenersCopy())
            l.onUserUpdated(ServerLobby.this, user);
    }

    private void handleUserUpdate(WebSocket conn, ServerLobbyMember user, int messageId, JSONObject data) throws JSONException {
        String newName = data.optString("name", null);
        NameCheck:
        if (newName != null) {
            if (TextUtils.isEmpty(newName)) break NameCheck;
            for (ServerLobbyMember mem : members) {
                if (Objects.equals(mem.getName(), newName)) {
                    conn.send(new JSONObject()
                            .put("id", messageId)
                            .put("type", "LobbyCtl.RESPONSE")
                            .put("status", -1)
                            .put("message", "Username is already in use")
                            .toString());
                    return;
                }
            }

            user.changeName(newName, null);
            conn.send(new JSONObject()
                    .put("id", messageId)
                    .put("type", "LobbyCtl.RESPONSE")
                    .put("status", 0)
                    .put("message", "Username updated")
                    .toString());
        }
        int permissions = data.optInt("permissions", user.getPermissions());
        user.changePermissionsInternally(permissions);

        broadcastEvent("Event.USER_UPDATED", user);

        for (LobbyEventListener l : safeListenersCopy())
            l.onUserUpdated(ServerLobby.this, user);
    }

    /**
     * Create safe copy of event listeners in case any of listeners decided to unregister self during pending iteration
     */
    public List<LobbyEventListener> safeListenersCopy() {
        synchronized (listenersUnsafe) {
            return new ArrayList<>(listenersUnsafe);
        }
    }

    /**
     * Stops server by user request
     * @deprecated use {@link #internalShutdown(Exception)} instead
     */
    @Deprecated
    public void stop() {
        internalShutdown(new Exception("External stop request"));
    }

    @Override
    public void changeTitle(String newName, Callback<Lobby> callback) {
        this.title = newName;

        if (callback != null) callback.onSuccess(this);
        broadcastEvent("Event.LOBBY_UPDATED", this);

        for (LobbyEventListener l : safeListenersCopy())
            l.onLobbyStateChanged(this);
    }

    @Override
    public void addEventListener(LobbyEventListener listener) {
        synchronized (listenersUnsafe) {
            this.listenersUnsafe.add(listener);
        }
    }

    @Override
    public void removeEventListener(LobbyEventListener listener) {
        synchronized (listenersUnsafe) {
            this.listenersUnsafe.remove(listener);
        }
    }

    @Override
    public String getTitle() {
        return title;
    }

    @Override
    public int getConnectionState() {
        return state;
    }

    @Override
    public QueueLooper getLooper() {
        return looper;
    }

    @Override
    public LibraryProvider getLibrary() {
        return libraryProvider;
    }

    @Override
    public int getPlayerState() {
        return playbackState;
    }

    @Override
    public List<LobbyMember> getMembers() {
        return Collections.unmodifiableList(members);
    }

    @Override
    public ServerLobbyMember getMemberById(int id) {
        for (ServerLobbyMember member : members)
            if (member.getId() == id) return member;
        return null;
    }

    @Override
    public LobbyMember getHost() {
        return selfMember;
    }

    @Override
    public LobbyMember getClient() {
        return selfMember;
    }

    @Override
    public VolumeControl getVolumeControl() {
        return null; // todo
    }

    @Override
    public void toJSON(JSONObject out) throws JSONException {
        JSONArray membersArray = new JSONArray();
        for (ServerLobbyMember member : members) {
            JSONObject dataJson = new JSONObject();
            member.toJSON(dataJson);
            membersArray.put(dataJson);
        }

        JSONObject looperJson = new JSONObject();
        if (looper instanceof JSONable) {
            ((JSONable) looper).toJSON(looperJson);
        } else Log.w("ServerLobby", "Warning: Looper is not JSONable. Can't serialize!");

        JSONObject libraryJson = new JSONObject();
        if (libraryProvider instanceof JSONable) {
            ((JSONable) libraryProvider).toJSON(libraryJson);
        } else Log.w("ServerLobby", "Warning: LibraryProvider is not JSONable. Can't serialize!");

        out.put("class", "Lobby")
                .put("values", new JSONObject()
                        .put("title", getTitle())
                        .put("hostId", selfMember.getId())
                        .put("members", membersArray)
                        .put("looper", looperJson)
                        .put("library", libraryJson)
                        .put("playerState", playbackState)
                );
    }
}